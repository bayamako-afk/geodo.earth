<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GUNO Simulation Map (Leaflet)</title>

  <!-- ✅ Leaflet: CDN版（今は確実に動く） -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; background: #0b0f14; }

    .panel {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1000;
      width: 360px;
      max-height: 70vh;
      overflow: auto;
      background: rgba(20, 24, 30, 0.92);
      color: #e8eef7;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 10px 12px;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .panel h1 {
      font-size: 14px;
      margin: 0 0 6px;
      letter-spacing: 0.02em;
    }
    .panel .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 6px 0;
      flex-wrap: wrap;
    }
    .panel button {
      background: rgba(255,255,255,0.10);
      color: #e8eef7;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 12px;
    }
    .panel button:hover { background: rgba(255,255,255,0.16); }
    .panel .list {
      margin-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.10);
      padding-top: 8px;
    }
    .item {
      display: grid;
      grid-template-columns: 22px 22px 16px 1fr auto;
      gap: 10px;
      align-items: center;
      padding: 6px 4px;
      border-radius: 10px;
    }
    .item:hover { background: rgba(255,255,255,0.06); }
    .swatch {
      width: 14px; height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.20);
    }
    .name {
      font-size: 12px;
      line-height: 1.25;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .meta {
      font-size: 11px;
      opacity: 0.8;
    }
    .hint {
      font-size: 11px;
      opacity: 0.75;
      margin-top: 6px;
    }
    .status {
      font-size: 11px;
      opacity: 0.85;
      margin-top: 8px;
      white-space: pre-wrap;
    }
    .pill {
      display: inline-block;
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.08);
      margin-left: 6px;
    }
    .legend {
      font-size: 11px;
      opacity: 0.8;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 1px 6px;
      border-radius: 8px;
      margin-left: 6px;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel">
    <h1>GUNO 路線ON/OFF <span class="pill" id="countPill">0/0</span></h1>

    <div class="row">
      <button id="btnAllOn">全ON</button>
      <button id="btnAllOff">全OFF</button>
      <button id="btnFit">全体表示</button>
      <button id="btnStationsOn">駅 全ON</button>
      <button id="btnStationsOff">駅 全OFF</button>
    </div>

    <div class="hint">
      ・路線クリックでハイライト<br/>
      ・左チェック：路線 / 右チェック：駅<br/>
      ・GeoJSONは <span class="kbd">geojson/lines/</span> と <span class="kbd">geojson/stations/</span> を参照
    </div>

    <div class="legend">
      <span class="kbd">路線</span> <span class="kbd">駅</span>
    </div>

    <div class="list" id="lineList"></div>
    <div class="status" id="status"></div>
  </div>

  <script>
    // ==========================
    // ① ここに路線リストを追加
    // ==========================
    // path / stationsPath は index.html からの相対パス
    const LINES = [
	  {
        slug: "jr-east-yamanote",
        name: "山手線",
        color: "#F39700",
        path: "./geojson/lines/jr-east-yamanote.geojson",
        stationsPath: "./geojson/stations/jr-east-yamanote_stations.geojson"
      },
      {
        slug: "tokyo-metro-ginza",
        name: "銀座線",
        color: "#00AA00",
        path: "./geojson/lines/tokyo-metro-ginza.geojson",
        stationsPath: "./geojson/stations/tokyo-metro-ginza_stations.geojson"
      },
      {
        slug: "tokyo-metro-tozai",
        name: "東西線",
        color: "#009BBF",
        path: "./geojson/lines/tokyo-metro-tozai.geojson",
        stationsPath: "./geojson/stations/tokyo-metro-tozai_stations.geojson"
      },
      {
        slug: "tokyo-metro-hanzomon",
        name: "半蔵門線",
        color: "#8F76D6",
        path: "./geojson/lines/tokyo-metro-hanzomon.geojson",
        stationsPath: "./geojson/stations/tokyo-metro-hanzomon_stations.geojson"
      },
	  {
        slug: "tokyo-metro-yurakucho",
        name: "有楽町線",
        color: "#C1A470",
        path: "./geojson/lines/tokyo-metro-yurakucho.geojson",
        stationsPath: "./geojson/stations/tokyo-metro-yurakucho_stations.geojson"
      },
       { 
	    slug: "tokyo-metro-marunouchi", 
		name: "丸ノ内線", 
		color: "#E60012",
        path: "./geojson/lines/tokyo-metro-marunouchi.geojson",
        stationsPath:"./geojson/stations/tokyo-metro-marunouchi_stations.geojson" },
    　];

    // ==========================
    // ② Leaflet map 初期化
    // ==========================
    const map = L.map("map", {
      zoomControl: true,
      preferCanvas: true,
    }).setView([35.681, 139.767], 11); // 東京駅あたり

    // --- ベースレイヤ（地図 & 航空写真） ---
    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    });

    const esri = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      {
        maxZoom: 19,
        attribution: "Tiles &copy; Esri"
      }
    );

    // デフォルトは航空写真
    esri.addTo(map);

    // レイヤ切替UI（右上）
    L.control.layers(
      { "航空写真": esri, "地図(OSM)": osm },
      null,
      { collapsed: true }
    ).addTo(map);

    // --- スタイル ---
    function lineStyle(color, highlighted=false) {
      return {
        color: color || "#76b7ff",
        weight: highlighted ? 8 : 5,
        opacity: highlighted ? 1.0 : 0.85
      };
    }

    function stationMarkerStyle(color) {
      return {
        radius: 4,
        weight: 1,
        opacity: 1,
        fillOpacity: 0.9,
        color: "#ffffff",
        fillColor: color || "#76b7ff"
      };
    }

    // ==========================
    // ③ UI生成 & GeoJSON読込
    // ==========================
    const lineListEl = document.getElementById("lineList");
    const statusEl = document.getElementById("status");
    const countPill = document.getElementById("countPill");

    const state = {
      layers: new Map(),        // slug -> L.GeoJSON (lines)
      stations: new Map(),      // slug -> L.GeoJSON (stations)
      meta: new Map(),          // slug -> meta
      highlightedSlug: null
    };

    function setStatus(msg) { statusEl.textContent = msg; }

    function updateCount() {
      const total = LINES.length;
      const on = LINES.filter(x => state.meta.get(x.slug)?.visible).length;
      countPill.textContent = `${on}/${total}`;
    }

    function buildItem(line) {
      const row = document.createElement("div");
      row.className = "item";

      // 路線ON/OFF
      const chkLine = document.createElement("input");
      chkLine.type = "checkbox";
      chkLine.checked = true;
      chkLine.title = "路線表示";

      // 駅ON/OFF（初期OFF推奨）
      const chkSt = document.createElement("input");
      chkSt.type = "checkbox";
      chkSt.checked = false;
      chkSt.title = "駅表示";

      const sw = document.createElement("div");
      sw.className = "swatch";
      sw.style.background = line.color || "#76b7ff";

      const labelWrap = document.createElement("div");
      const nameEl = document.createElement("div");
      nameEl.className = "name";
      nameEl.textContent = `${line.name} (${line.slug})`;

      const metaEl = document.createElement("div");
      metaEl.className = "meta";
      metaEl.textContent = "loading…";

      labelWrap.appendChild(nameEl);
      labelWrap.appendChild(metaEl);

      const btn = document.createElement("button");
      btn.textContent = "ズーム";
      btn.style.padding = "5px 8px";

      row.appendChild(chkLine);
      row.appendChild(chkSt);
      row.appendChild(sw);
      row.appendChild(labelWrap);
      row.appendChild(btn);

      lineListEl.appendChild(row);

      state.meta.set(line.slug, {
        name: line.name,
        color: line.color,
        path: line.path,
        stationsPath: line.stationsPath,
        loaded: false,
        visible: true,
        stLoaded: false,
        stVisible: false,
        metaEl,
        nameEl,
        sw,
        chkLine,
        chkSt
      });

      chkLine.addEventListener("change", async () => {
        const m = state.meta.get(line.slug);
        m.visible = chkLine.checked;

        // 初回ONで遅延ロード
        if (chkLine.checked && !m.loaded) {
          await loadLine(line.slug);
        }
        toggleLayer(line.slug, chkLine.checked);
        updateCount();
      });

      chkSt.addEventListener("change", async () => {
        const m = state.meta.get(line.slug);
        m.stVisible = chkSt.checked;

        if (chkSt.checked && !m.stLoaded) {
          await loadStations(line.slug);
        }
        toggleStations(line.slug, chkSt.checked);
      });

      btn.addEventListener("click", async () => {
        const m = state.meta.get(line.slug);
        if (!m.loaded) await loadLine(line.slug);
        fitToLine(line.slug);
      });
    }

    async function loadLine(slug) {
      const m = state.meta.get(slug);
      if (!m || m.loaded) return;

      setStatus(`Loading line: ${slug} …`);
      try {
        const res = await fetch(m.path, { cache: "no-store" });
        if (!res.ok) throw new Error(`fetch failed: ${m.path} (${res.status})`);
        const gj = await res.json();

        const prop0 = (gj.features && gj.features[0] && gj.features[0].properties) ? gj.features[0].properties : {};
        const color = prop0.color || m.color || "#76b7ff";
        const dispName = prop0.official_name || prop0.name_en || m.name || slug;

        m.color = color;
        m.name = dispName;
        m.sw.style.background = color;
        m.nameEl.textContent = `${dispName} (${slug})`;

        const layer = L.geoJSON(gj, {
          style: () => lineStyle(color, false),
          onEachFeature: (feature, lyr) => {
            lyr.on("click", () => {
              highlight(slug);
              const p = feature.properties || {};
              const title = p.official_name || p.name_en || dispName;
              const code = p.line_code ? ` / ${p.line_code}` : "";
              lyr.bindPopup(`<b>${title}</b>${code}<br/><small>${slug}</small>`).openPopup();
            });
          }
        });

        state.layers.set(slug, layer);
        m.loaded = true;

        if (m.visible) layer.addTo(map);

        const geomType = (gj.features && gj.features[0] && gj.features[0].geometry) ? gj.features[0].geometry.type : "unknown";
        m.metaEl.textContent = `${geomType} / features: ${(gj.features || []).length}`;

        setStatus(`Loaded line: ${slug}`);
      } catch (e) {
        m.metaEl.textContent = `ERROR`;
        setStatus(String(e));
        console.error(e);
      }
    }

    async function loadStations(slug) {
      const m = state.meta.get(slug);
      if (!m || !m.stationsPath || m.stLoaded) return;

      setStatus(`Loading stations: ${slug} …`);
      try {
        const res = await fetch(m.stationsPath, { cache: "no-store" });
        if (!res.ok) throw new Error(`fetch failed: ${m.stationsPath} (${res.status})`);
        const gj = await res.json();

        const color = m.color || "#76b7ff";

        const layer = L.geoJSON(gj, {
          pointToLayer: (feature, latlng) => L.circleMarker(latlng, stationMarkerStyle(color)),
          onEachFeature: (feature, lyr) => {
            lyr.on("click", () => {
              const p = feature.properties || {};
              const name = p["name"] || p["name:ja"] || p["name_en"] || "station";
              const ord = (p.station_order != null) ? `#${p.station_order}` : "";
              lyr.bindPopup(`<b>${name}</b> ${ord}<br/><small>${slug}</small>`).openPopup();
            });
          }
        });

        state.stations.set(slug, layer);
        m.stLoaded = true;

        if (m.stVisible) layer.addTo(map);

        setStatus(`Stations loaded: ${slug}`);
      } catch (e) {
        setStatus(String(e));
        console.error(e);
      }
    }

    function toggleLayer(slug, on) {
      const layer = state.layers.get(slug);
      if (!layer) return;
      if (on) layer.addTo(map);
      else map.removeLayer(layer);
    }

    function toggleStations(slug, on) {
      const layer = state.stations.get(slug);
      if (!layer) return;
      if (on) layer.addTo(map);
      else map.removeLayer(layer);
    }

    function fitToLine(slug) {
      const layer = state.layers.get(slug);
      if (!layer) return;
      const b = layer.getBounds();
      if (b && b.isValid()) map.fitBounds(b.pad(0.12));
    }

    function fitAllVisible() {
      const bounds = [];
      for (const line of LINES) {
        const m = state.meta.get(line.slug);
        const layer = state.layers.get(line.slug);
        if (m?.visible && layer) {
          const b = layer.getBounds();
          if (b && b.isValid()) bounds.push(b);
        }
      }
      if (bounds.length === 0) return;
      let b0 = bounds[0];
      for (let i=1; i<bounds.length; i++) b0 = b0.extend(bounds[i]);
      map.fitBounds(b0.pad(0.10));
    }

    function highlight(slug) {
      if (state.highlightedSlug && state.layers.get(state.highlightedSlug)) {
        const prev = state.layers.get(state.highlightedSlug);
        const prevMeta = state.meta.get(state.highlightedSlug);
        prev.setStyle(lineStyle(prevMeta?.color, false));
      }
      state.highlightedSlug = slug;
      const layer = state.layers.get(slug);
      const m = state.meta.get(slug);
      if (layer && m) layer.setStyle(lineStyle(m.color, true));
    }

    // --- buttons ---
    document.getElementById("btnAllOn").addEventListener("click", async () => {
      for (const line of LINES) {
        const m = state.meta.get(line.slug);
        m.visible = true;
        m.chkLine.checked = true;

        if (!m.loaded) await loadLine(line.slug);
        toggleLayer(line.slug, true);
      }
      updateCount();
      fitAllVisible();
      setStatus("All lines ON");
    });

    document.getElementById("btnAllOff").addEventListener("click", () => {
      for (const line of LINES) {
        const m = state.meta.get(line.slug);
        m.visible = false;
        m.chkLine.checked = false;
        toggleLayer(line.slug, false);
      }
      updateCount();
      setStatus("All lines OFF");
    });

    document.getElementById("btnFit").addEventListener("click", () => fitAllVisible());

    document.getElementById("btnStationsOn").addEventListener("click", async () => {
      for (const line of LINES) {
        const m = state.meta.get(line.slug);
        m.stVisible = true;
        m.chkSt.checked = true;
        if (!m.stLoaded) await loadStations(line.slug);
        toggleStations(line.slug, true);
      }
      setStatus("All stations ON");
    });

    document.getElementById("btnStationsOff").addEventListener("click", () => {
      for (const line of LINES) {
        const m = state.meta.get(line.slug);
        m.stVisible = false;
        m.chkSt.checked = false;
        toggleStations(line.slug, false);
      }
      setStatus("All stations OFF");
    });

    // UI生成
    for (const line of LINES) buildItem(line);

    // 初期ロード（路線は全部ON、駅は全部OFF）
    (async () => {
      setStatus("Loading all lines …");
      await Promise.all(LINES.map(x => loadLine(x.slug)));
      updateCount();
      fitAllVisible();
      setStatus("Ready (Lines ON / Stations OFF)");
    })();
  </script>
</body>
</html>
